<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pointers - fast_io Documentation</title>
  <link rel="stylesheet" href="/style.css">
  <link rel="manifest" href="/manifest.json">
</head>
<body>
  <main>
    <h1>Pointers</h1>

    <section>
      <h2>Introduction</h2>
      <p>
        In <code>fast_io</code>, raw pointers and iterators are not printed directly. This is a deliberate
        safety choice: printing them without explicit intent can lead to undefined or inconsistent
        behavior across platforms. Instead, <code>fast_io</code> provides a family of <strong>pointer‑related
        manipulators</strong> that make the intent explicit and ensure consistent, portable formatting.
      </p>
    </section>

    <section>
      <h2>Pointer Manipulators Overview</h2>
      <p>
        The following manipulators provide safe, explicit, and portable ways to print pointers,
        member pointers, and OS handles. Each manipulator clearly expresses the programmer’s intent
        and avoids the undefined behavior associated with printing raw pointers directly.
      </p>
      <ul>
        <li><code>pointervw(ptr)</code> — prints the raw address of a pointer in fixed‑width hexadecimal.</li>
        <li><code>os_c_str(ptr)</code> — treats a <code>char const*</code> as a C‑string, using <code>strlen</code> or <code>strnlen</code>.</li>
        <li><code>fieldptrvw(m)</code> — prints member object pointers, showing the ABI‑specific encoding of a field inside a class.</li>
        <li><code>funcvw(f)</code> — prints the address of a free function.</li>
        <li><code>methodvw(m)</code> — prints member function pointers, including offset information for multiple inheritance.</li>
        <li><code>handlevw(h)</code> — prints operating system handles, whether represented as integers (POSIX fd) or pointers (Win32 <code>HANDLE</code>, <code>FILE*</code>).</li>
      </ul>
    </section>

    <section>
      <h2>Printing Pointers</h2>
      <p>
        Use <code>pointervw</code> to print raw addresses. The format is consistent across platforms:
        <code>0x</code> followed by 8 hex digits on 32‑bit systems, or 16 hex digits on 64‑bit systems.
      </p>
      <pre><code class="language-cpp">
#include &lt;fast_io.h&gt;

int main()
{
    using namespace ::fast_io::iomnp;
    int x{42};
    int *ptr{::std::addressof(x)};
    println("Address:", pointervw(ptr));
}
      </code></pre>
    </section>

    <section>
      <h2>C‑String Manipulator</h2>
      <p>
        To treat a <code>char const*</code> as a C‑string, use <code>os_c_str</code>. This calls
        <code>strlen</code> or <code>strnlen</code> depending on overload.
      </p>
      <pre><code class="language-cpp">
#include &lt;fast_io.h&gt;

int main()
{
    using namespace fast_io::iomnp;
    constexpr char const* ptr{"Hello\0World\n"};

    println(
        "Literal: Hello\0World\n\n"
        "Pointer:", pointervw(ptr), "\n"
        "os_c_str:", os_c_str(ptr), "\n"
        "os_c_str(ptr,4):", os_c_str(ptr,4), "\n"
        "os_c_str(ptr,10):", os_c_str(ptr,10)
    );
}
      </code></pre>
    </section>

    <section>
      <h2>Field Pointers</h2>
      <p>
        A pointer‑to‑member <em>data</em> does not refer to an address in memory. Instead, it encodes
        the position of a field inside a class. The exact representation varies across ABIs, so
        <code>fieldptrvw</code> prints the underlying bytes in a consistent hexadecimal format.
      </p>
      <pre><code class="language-cpp">
#include &lt;fast_io.h&gt;

struct point
{
    double x;
    double y;
};

int main()
{
    using namespace ::fast_io::iomnp;

    println(
        "fieldptrvw(&point::x): ", fieldptrvw(&point::x), "\n",
        "fieldptrvw(&point::y): ", fieldptrvw(&point::y)
    );
}
      </code></pre>
    </section>

    <section>
      <h2>Function and Method Pointers</h2>
      <p>
        <code>funcvw</code> prints the address of a free function. <code>methodvw</code> prints member
        function pointers, including offset information for multiple inheritance cases.
      </p>
      <pre><code class="language-cpp">
#include &lt;fast_io.h&gt;
#include &lt;memory&gt;

class dummy_class { public: void dummy_method() noexcept {} };
struct A { virtual void f() noexcept {} };
struct B { virtual void g() noexcept {} };
struct C : A, B {};

void foo(){}

int main()
{
    using namespace ::fast_io::iomnp;
    void (C::*downcptr)() noexcept = &B::g;

    println(
        "funcvw(foo):", funcvw(foo), "\n"

        "methodvw(&dummy_class::dummy_method):",
        methodvw(&dummy_class::dummy_method), "\n"

        "methodvw(downcptr):", methodvw(downcptr)
    );
}
      </code></pre>
    </section>

    <section>
      <h2>Handles</h2>
      <p>
        <code>handlevw</code> is used when printing operating system handles. A handle may be an
        integer (POSIX file descriptor) or a pointer (Win32 <code>HANDLE</code>, <code>FILE*</code>).
        <code>handlevw</code> adapts automatically, printing integers directly and pointers in
        consistent hexadecimal format.
      </p>
      <pre><code class="language-cpp">
#include &lt;fast_io.h&gt;
#include &lt;cstdio&gt;

int main()
{
    using namespace ::fast_io::iomnp;
    int fd{3};       // POSIX file descriptor
    FILE *f{stdout};

    println(
        "POSIX fd:", handlevw(fd), "\n"
        "FILE* handle:", handlevw(f)
    );
}
      </code></pre>
    </section>

    <section>
      <h2>Key takeaways</h2>
      <p>
        Pointer‑related manipulators in <code>fast_io</code> make printing low‑level entities explicit,
        safe, and portable. They cover raw pointers, C‑strings, free functions, member functions,
        member data, and OS handles. This design avoids the unsafe and inconsistent behavior of
        <code>stdio</code> and <code>iostream</code>.
      </p>
    </section>

    <script src="/sw-register.js"></script>
    <div class="page-navigation">
      <a href="/docs/01.io/02.aplusb/" class="prev-button">← 1.2 A+B</a>
      <a href="/" class="main-button">↑ Main Page</a>
      <a href="/docs/01.io/04.fileio/" class="next-button"> Next: File I/O →</a>
    </div>
  </main>
</body>
</html>
