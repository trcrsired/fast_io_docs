<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ch4.3: array - C++ Tutorial with fast_io</title>
  <link rel="stylesheet" href="/style.css">
  <link rel="manifest" href="/manifest.json">
</head>
<body>
  <main>
    <h1>::fast_io::array</h1>

    <section>
      <h2>1. What is an array?</h2>
      <p>
        A <code>::fast_io::array&lt;T, N&gt;</code> stores exactly <code>N</code> elements of type <code>T</code>.
        The size is fixed at compile time and never changes.
      </p>
      <p>
        Because the size is known ahead of time, the array stores its elements directly inside the object itself.
        There is no dynamic allocation and no resizing.
      </p>
      <p>
        For most situations, you should prefer <code>::fast_io::vector&lt;T&gt;</code> because it grows automatically.
        <code>::fast_io::array</code> is useful when the size is truly fixed and known in advance.
      </p>
    </section>

    <section>
      <h2>2. Creating an array</h2>
      <p>You specify both the element type and the number of elements:</p>

<pre><code class="language-cpp">
#include <fast_io.h>
#include <fast_io_dsal/array.h>

int main() {
    using namespace ::fast_io::iomnp;

    ::fast_io::array<std::size_t, 3zu> a{1zu, 2zu, 3zu};
    println("a[0] = ", a[0]);
}
</code></pre>

      <p>
        If you do not provide initial values, the elements are default‑initialized:
      </p>

<pre><code class="language-cpp">
::fast_io::array<std::size_t, 5zu> b{}; // all elements default-initialized
</code></pre>
    </section>

    <section>
      <h2>3. Accessing elements</h2>
      <p>
        Access works the same way as with <code>::fast_io::vector</code>:
      </p>

<pre><code class="language-cpp">
#include <fast_io.h>
#include <fast_io_dsal/array.h>

int main() {
    using namespace ::fast_io::iomnp;

    ::fast_io::array<std::size_t, 4zu> a{10zu, 20zu, 30zu, 40zu};

    println("Front: ", a.front()); // 10
    println("Back: ",  a.back());  // 40
    println("Index 2: ", a[2]);    // 30
}
</code></pre>

      <p>
        ⚠️ <strong>Safety note:</strong> If you use an out‑of‑range index, <code>fast_io</code> calls
        <code>fast_terminate()</code> immediately.
      </p>

      <h4>Safe usage</h4>
<pre><code class="language-cpp">
std::size_t i = 2zu;
if(i < a.size()) {
    println("a[2] = ", a[i]);
}
</code></pre>
    </section>

    <section>
      <h2>4. Iterating through elements</h2>

      <h3>Range‑based for loop</h3>
      <p>
        Just like strings and vectors, arrays support range‑based for loops:
      </p>

<pre><code class="language-cpp">
for(std::size_t x : a) {
    println(x);
}
</code></pre>

      <h3>Index loop</h3>
<pre><code class="language-cpp">
for(std::size_t i{}, n{a.size()}; i != n; ++i) {
    println("Index ", i, ": ", a[i]);
}
</code></pre>

      <h3>Advanced: Iterators</h3>
      <p>
        Arrays use the same iterator model introduced in <strong>3.1 (string)</strong> and used again in
        <strong>4.2 (vector)</strong>. Iterators:
      </p>
      <ul>
        <li>are contiguous</li>
        <li>support arithmetic (<code>+/-</code>, <code>[]</code>, comparisons)</li>
        <li>use the left‑inclusive, right‑exclusive range <code>[begin(), end())</code></li>
      </ul>

<pre><code class="language-cpp">
for(auto it = a.begin(), ed = a.end(); it != ed; ++it) {
    println(*it);
}
</code></pre>

      <p>
        Because the size is fixed and no reallocation ever happens, array iterators never become invalid.
      </p>
    </section>

    <section>
      <h2>5. Utility functions</h2>

      <h3>fill()</h3>
      <p>Sets all elements to the same value:</p>

<pre><code class="language-cpp">
a.fill(7zu); // all elements become 7
</code></pre>

      <h3>swap()</h3>
      <p>Swaps the contents of two arrays of the same size:</p>

<pre><code class="language-cpp">
::fast_io::array<std::size_t, 3zu> x{1zu, 2zu, 3zu};
::fast_io::array<std::size_t, 3zu> y{9zu, 8zu, 7zu};

x.swap(y);
</code></pre>
    </section>

    <section>
      <h2>Key takeaways</h2>
      <ul>
        <li><code>::fast_io::array&lt;T, N&gt;</code> stores exactly <code>N</code> elements with no dynamic allocation.</li>
        <li>The size is fixed at compile time and cannot grow or shrink.</li>
        <li>Access functions (<code>front()</code>, <code>back()</code>, <code>operator[]</code>) behave like those in vectors.</li>
        <li>Array iterators behave exactly like string and vector iterators, but never become invalid.</li>
        <li><code>fill()</code> and <code>swap()</code> provide convenient ways to modify the entire array.</li>
        <li>For most tasks, prefer <code>::fast_io::vector&lt;T&gt;</code> — it is the default container and grows automatically.</li>
      </ul>
    </section>

    <script src="/sw-register.js"></script>
    <div class="page-navigation">
      <a href="/docs/04.dsal/02.vector/" class="prev-button">← Ch4.2: vector</a>
      <a href="/" class="main-button">↑ Main Page</a>
      <a href="/docs/04.dsal/04.multidcontainers/" class="next-button">Ch4.4: Multi‑Dimension Containers →</a>
    </div>
  </main>
</body>
</html>
