<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ch4.2: vector - C++ Tutorial with fast_io</title>
  <link rel="stylesheet" href="/style.css">
  <link rel="manifest" href="/manifest.json">
</head>
<body>
  <main>
    <h1>::fast_io::vector</h1>

    <section>
      <h2>1. What is a vector?</h2>
      <p>
        A <code>::fast_io::vector&lt;T&gt;</code> stores a sequence of elements of type <code>T</code>.
        It grows automatically when you add more items, and all elements stay together in one continuous block of memory.
      </p>
      <p>
        You can think of it as a “growing list of values” that keeps everything tightly packed.
      </p>
    </section>

    <section>
      <h2>2. Creating a vector</h2>
      <p>You can create an empty vector or one with an initial size:</p>

<pre><code class="language-cpp">
#include &lt;fast_io.h&gt;
#include &lt;fast_io_dsal/vector.h&gt;

int main() {
    using namespace ::fast_io::iomnp;

    ::fast_io::vector&lt;std::size_t&gt; a;            // empty
    ::fast_io::vector&lt;std::size_t&gt; b(5zu);       // 5 default-initialized elements
    ::fast_io::vector&lt;std::size_t&gt; c(3zu, 42zu); // 3 copies of value 42

    println("b size = ", b.size());
    println("c[0] = ", c[0]);
}
</code></pre>
    </section>

    <section>
      <h2>3. Adding elements</h2>
      <p>
        The most common way to add elements is <code>push_back()</code>:
      </p>

<pre><code class="language-cpp">
#include &lt;fast_io.h&gt;
#include &lt;fast_io_dsal/vector.h&gt;

int main() {
    using namespace ::fast_io::iomnp;

    ::fast_io::vector&lt;std::size_t&gt; v;

    v.push_back(10zu);
    v.push_back(20zu);
    v.push_back(30zu);

    println("Size: ", v.size()); // 3
}
</code></pre>

      <p>
        When the vector runs out of space, it automatically allocates more memory.
      </p>
    </section>

    <section>
      <h2>4. Accessing elements safely</h2>
      <p>
        You can access elements using <code>front()</code>, <code>back()</code>, or <code>operator[]</code>:
      </p>

<pre><code class="language-cpp">
#include &lt;fast_io.h&gt;
#include &lt;fast_io_dsal/vector.h&gt;

int main() {
    using namespace ::fast_io::iomnp;

    ::fast_io::vector&lt;std::size_t&gt; v{1zu, 2zu, 3zu, 4zu};

    println("Front: ", v.front()); // 1
    println("Back: ",  v.back());  // 4
    println("Index 2: ", v[2]);    // 3
}
</code></pre>

      <p>
        ⚠️ <strong>Safety note:</strong> If you access an element that does not exist (for example, calling
        <code>v.front()</code> on an empty vector or using an out-of-range index), <code>fast_io</code> performs a
        boundary check. If the check fails, the program stops immediately using <code>__builtin_trap()</code>.
      </p>

      <h4>Safe usage</h4>
<pre><code class="language-cpp">
if(!v.is_empty()) {
    println("Front: ", v.front());
}

std::size_t i = 2zu;
if(i &lt; v.size()) {
    println("v[2] = ", v[i]);
}
</code></pre>
    </section>

    <section>
      <h2>5. Iterating through elements</h2>

      <h3>Preferred: Range‑based for loop</h3>
      <p>This is the simplest way to go through all elements:</p>

<pre><code class="language-cpp">
#include &lt;fast_io.h&gt;
#include &lt;fast_io_dsal/vector.h&gt;

int main() {
    using namespace ::fast_io::iomnp;

    ::fast_io::vector&lt;std::size_t&gt; v{10zu, 20zu, 30zu};

    for(std::size_t x : v) {
        println(x);
    }
}
</code></pre>

      <h3>Alternative: Index loop</h3>
      <p>Useful when you need the position:</p>

<pre><code class="language-cpp">
for(std::size_t i{}, n{v.size()}; i != n; ++i) {
    println("Index ", i, ": ", v[i]);
}
</code></pre>

      <h3>Advanced: Iterators</h3>
      <p>
        In <strong>Section 3.1 (string iterators)</strong>, we introduced the idea that an iterator behaves like a pointer
        into a container’s memory. A <code>::fast_io::vector&lt;T&gt;</code> uses the <strong>same iterator model</strong>
        as <code>::fast_io::string</code>.
      </p>

      <p>
        This means:
      </p>
      <ul>
        <li>iterators are contiguous and support arithmetic (<code>+/-</code>, <code>[]</code>, comparisons)</li>
        <li>iteration uses a left‑inclusive, right‑exclusive range: <code>[begin(), end())</code></li>
        <li>stepping outside this range is undefined behavior</li>
        <li>iterators become invalid if the vector reallocates (for example, after <code>push_back()</code> when full)</li>
      </ul>

      <p>Example:</p>

<pre><code class="language-cpp">
#include &lt;fast_io.h&gt;
#include &lt;fast_io_dsal/vector.h&gt;

int main() {
    using namespace ::fast_io::iomnp;

    ::fast_io::vector&lt;std::size_t&gt; v{10zu, 20zu, 30zu};

    for(auto it = v.begin(), ed = v.end(); it != ed; ++it) {
        println(*it);
    }
}
</code></pre>

      <h4>Iterator arithmetic</h4>
      <p>
        Just like with strings, vector iterators allow random‑access operations:
      </p>

<pre><code class="language-cpp">
auto it = v.begin();        // first element
println(*(it + 1));         // move forward
println((it + 2)[0]);       // same as v[2]
println((it + 2)[-1]);      // move backward from a valid position
</code></pre>

      <p>
        These operations are fast, but they do <strong>not</strong> check bounds.
      </p>

      <h4>Iterator invalidation</h4>
      <p>
        Any operation that causes the vector to grow may reallocate its storage.
        When this happens, <strong>all existing iterators become invalid</strong>.
      </p>

<pre><code class="language-cpp">
auto it2 = v.begin();
v.push_back(999zu);  // may reallocate

// ⚠️ it2 may now point to old memory
// println(*it2);   // undefined behavior
</code></pre>

      <p>
        If you need to keep positions across reallocation, store an index instead of an iterator.
      </p>
    </section>

    <section>
      <h2>6. Removing elements</h2>

      <h3>pop_back()</h3>
      <p>Removes the last element:</p>

<pre><code class="language-cpp">
v.pop_back();
</code></pre>

      <p>
        ⚠️ Calling <code>pop_back()</code> on an empty vector stops the program immediately.
      </p>
    </section>

    <section>
      <h2>7. Clearing and releasing memory</h2>

      <h3>clear()</h3>
      <p>
        Removes all elements but <strong>keeps the allocated memory</strong>.  
        This is useful when you plan to reuse the vector soon.
      </p>

<pre><code class="language-cpp">
v.clear();
println(v.size()); // 0
</code></pre>

      <h3>clear_destroy()</h3>
      <p>
        Removes all elements <strong>and releases the memory back to the allocator</strong>.  
        After this call, the vector becomes completely empty with no storage.
      </p>

<pre><code class="language-cpp">
v.clear_destroy(); // memory returned to allocator
println(v.size()); // 0
</code></pre>

      <p>
        Use <code>clear_destroy()</code> when you are done with the vector and want to free its memory.
      </p>
    </section>

    <section>
      <h2>Key takeaways</h2>
      <ul>
        <li><code>::fast_io::vector&lt;T&gt;</code> stores a growing sequence of tightly packed elements.</li>
        <li><code>push_back()</code> adds new items and expands storage automatically when needed.</li>
        <li><code>front()</code>, <code>back()</code>, and <code>operator[]</code> give fast access, but require manual bounds checking.</li>
        <li>Vector iterators behave exactly like string iterators: contiguous, arithmetic‑friendly, and using <code>[begin(), end())</code>.</li>
        <li><code>clear()</code> removes elements but keeps memory; <code>clear_destroy()</code> removes elements and frees memory.</li>
      </ul>
    </section>

    <script src="/sw-register.js"></script>
    <div class="page-navigation">
      <a href="/docs/04.dsal/01.string/" class="prev-button">← Ch4.1: string</a>
      <a href="/" class="main-button">↑ Main Page</a>
      <a href="/docs/04.dsal/03.array/" class="next-button">Ch4.3: array →</a>
    </div>
  </main>
</body>
</html>
